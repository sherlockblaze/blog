---
title: Linux是如何工作的--Linux系统总览
tags:
  - Linux是如何工作的
  - Linux
  - Linux 内核
date: 2019-03-12
---

## Linux 系统总览

> 本文所总结的内容都来自于： **[《How Linux Works》](https://www.amazon.com/How-Linux-Works-2nd-Superuser/dp/1593275676/ref=sr_1_1?keywords=how+linux+works&qid=1551169061&s=gateway&sr=8-1)**.

### 关于如何理解学习

学习理解一个操作系统如何工作的最好方式，莫过于***抽象***，通过抽象你可以在刚开始的时候去选择忽略掉一些细节。举个例子来讲，当你驾驶一辆车，一般情况下，你不需要去知道车是谁制造的，路是谁搭的。特别的是如果你是一个乘客，那你唯一需要知道的就是这是辆什么车以及怎么去使用它。但是，如果你是驾驶员，你就需要知道更多了，你需要知道如何去操控车，当车出现一些故障的时候，你需要知道如何去处理。

举个例子，我们假设车开起来很不爽，一直在颠簸。现在你需要将 “一辆车开在路上” 这个问题抽象成为：一辆车、一条路以及你驾驶技术。这样可以帮你分解问题：如果这个路有问题，你就不需要特别去考虑你的车或者你驾驶技术的问题。于是你就进一步去探索路的问题。

程序员在创造一个操作系统和在其环境下运行的应用程序时会利用抽象。计算机软件中的抽象细分有很多术语，包括子系统、模块、组件和包，在构建软件组件时，程序员通常不会考虑其他组件的内部结构，但需要了解他们可以使用的其他组件以及如何使用它们。

### Linux 系统中抽象层次和层级

Linux系统中主要有三个层。下面的图片展示了这三个层以及各个层对应的一些组件。**硬件**是最底下的一层，硬件包括了存储以及一个或多个CPU —— 用于从存储中读取数据并计算/写入输入。像一些磁盘，网络接口之类，也是硬件的一部分。

往上一个层级是Linux内核，是操作系统的核心。**内核常驻于内存中，它会告诉CPU去做什么。**它就像是硬件和各个运行程序之间的接口，用来管理硬件。


***进程*** —— 被内核管理的运行中的程序 —— 共同组成了操作系统的上层，被称为***用户空间***。（进程用一个更常见的术语描述是***用户进程***，不管用户是否可以直接和进程进行交互。比如说，所有的Web服务都是以用户进程的方式来运行。）

![General Linux System Organization](https://sherlockblaze.com/resources/img/linux/how-linux-works/general-linux-system-organization.png)

用户进程和内核进程最明显的不同就是：用户进程运行在**用户模式**，而内核进程运行在**内核模式**。在内核模式下运行的程序可以访问到处理器和主存。而只有内核能访问到的区域被称为**内核空间**

> 这是一个很有力但是危险的特权，因为内核进程可以很轻松让整个操作系统瘫痪。

**用户模式**，和内核模式比较着来说，它仅能访问部分内存，和进行被系统认为安全的CPU操作。***用户空间***用来表示在主存里可以被用户进程访问到的空间。如果一个进程出了问题甚至崩溃，它的危害会被限制在系统之外，内核会负责清理掉它。比如说，你的浏览器程序奔溃了，一般来说，是不会影响到你后台运行了几天的科学计算的。

### 硬件：理解主存

在所有的硬件设备里，***主存（内存）***可能是最重要的。在它最原始的表示下，主存只是存放了一堆0/1的区域，每个0/1我们称之为一个***bit（位）***。内存同时也是内核生存的地方，内核常驻于内存，它要负责告诉CPU去做些什么事情，需要去管理硬件。所有的从外设获取到的输入输出都需要经过内存，同样也是一堆 bits。而CPU则是一个内存操作师，它从内存中读取数据（指令等）并向内存中写入处理后的结果。

我们在讨论内存、进程、内核或者其他关于计算机系统的时候，经常会有这样一个名词 —— ***状态***。比如说这个状态，其实也是一个由0、1组合而成的序列。比如，如果你用四个比特表示一个状态，那么 0110,0001，还有1011表示三种不同的状态。

**注意：**一般来说我们会用抽象术语 —— 状态来描述，而不是直接用二进制序列来描述，术语代表着某些约定好的二进制序列。比如，停止状态代表***0001***（举个例子）

### 内核

内核所做的一切几乎都围绕主内存。内核的主要工作之一就是 **把内存划分为多个区域，并且它必须要一直维护这些区域的状态信息。每个进程都可以在内存中拿到属于自己的一部分，内核需要保证这一点。**

内核有以下**四个**重点工作需要负责：

- **进程管理：**进程要负责管理每个进程，判断它们是否有权限去使用CPU。
- **内存：**内核需要监控所有的内存。—— 给指定进程分配空间、哪些部分可以被多个进程共享、哪些空间是空闲的，等等。
- **设备驱动：**内核就像是硬件和进程之间的一个接口，一般来说，操作硬件的工作是由内核来负责的。
- **系统调用支持：**进程通常利用**系统调用**的方式和内核进行交互。

#### 进程管理

***进程管理*** 负责进程的启动、暂停、恢复和终止。

现代操作系统中，很多进程是“同时“运行的。比如说，你可能同时运行着浏览器和音乐播放器。但是，事实往往不像表面上一样：进程在背后**并不是真正地**同时运行。

**上下文切换：**想象一个单核CPU，所有的进程都有权限去使用CPU，但是其实只有一个进程可以在某个时刻使用CPU，每个进程都仅仅是在某个时间段里使用CPU，然后暂停；然后另一个进程在运行一段时间，以此类推。像这种，一个进程放弃CPU使用权限，然后另一个进程获得CPU使用权限的过程，称为***上下文切换***。

**时间片：**上面提到的一小段时间一般被称为***时间片**。一般来说，时间片持续的时间都很短，以至于人类不会对此有感知，所以就好像有很多进程在同时运行一样。也就是被我们所知晓的”多进程“。

**上下文切换是如何工作的？？**

> 内核负责。以下是上下文切换过程中发生的事情：

1. CPU根据时间片的长度来中断正在运行的进程，然后切换到内核模式，控制权回到内核。
2. 内核记录当前CPU和内存的状态，这个操作对于后面恢复上一步被中断的进程来说至关重要。
3. 内核执行上个时间片里可能有的任何任务（比如从输入输出设备中收集数据，或者I/O操作等等）
4. 到了这里，内核已经准备好让另一个进程运行了。内核在等待队列中分析挑选一个进程取运行。
5. 内核为新的进程分配内存，准备CPU 。
6. 内存告诉CPU这个进程准备运行多长时间。
7. 内核切换CPU到用户模式然后把CPU的使用权交给进程。

**上下文切换回答了内核何时运行的重要问题。答案是：在两个进程时间片中间的上下文切换的时间中。**

**注意：**

在多CPU系统中，事情会有一些变化。内核不需要放弃对目前CPU的控制权为了让一个进程运行，而仅仅是让目标进程运行在某个不同的CPU上。但是，为了最大化的使用CPU，内核通常还是会放弃CPU的控制权，但是会使用一些小技巧来扩大自己使用CPU的时间。

#### 内存管理

内核上下文切换的时候管理内存，这是一个艰巨的任务。这个工作属于**内存管理器**。为什么说是个艰巨的任务呢？因为内核必须要保证以下几个点：

- 内核在内存中必须有一个块属于自己的私密小空间，其他任何用户进程都访问不到。
- 每个用户进程都有自己的小空间
- 一个进程需要被保证无法访问另一个进程的私密空间
- 用户进程可以共享空间
- 一些内存对于用户进程来说是只读的
- 通过物理硬盘作为辅助，系统可以使用到比实际存在更多的内存

想要做到以上几点很困难。但是很幸运，内核有好帮手。现在CPUs包括了一个 **内存管理单元(MMU)**，它支持一个可访问空间，被称为**虚拟存储**。当使用虚拟内存的时候，内核保证每个进程过得就好像这个电脑都是自己的一样，**一个进程不是直接访问内存在硬件上的物理地址**，当进程访问一些属于它的存储时，MMU把这些访问使用内存地址映射，映射成一个在机器上的实际地址。
**内存需要一直初始化和持续维护内存地址映射。举个例子，在一个上下文切换过程中，内核必须要调整映射关系到下一个进程需要的。**

**注意：**内存地址映射的实现称为**页表（page table）**。

#### 设备驱动及管理

内核相对于设备的角色比较简单。只有在内核模式下才能访问设备，因为不恰当的访问会毁掉整个机器。另一个问题是，不同的设备很少会有相同的编程借口，哪怕两个设备是一件东西，比如两个相同的网卡。因此，设备驱动一般是内核的一部分，通过这个方式来向开发者提供统一接口。

#### 系统调用和支持

通过**系统调用（syscalls）**，内核的一些功能是可以被用户进程使用的。有一些操作仅仅靠用户进程自己是无法完成的，比如I/O操作，读写文件等。

有两个系统调用对于理解进程如何启动非常重要：`fork()` 和 `exec()`：

- **fork()** 当一个进程调用 `fork()`, 内核会创建一个跟调用进程几乎相同的进程
- **exec()** 当一个进程调用 `exec(program)` ，进程会启动一个进程，替代掉调用的进程

**除了`init`进程，Linux系统下所有的用户进程都是 `fork()`的产物**，大部分时间，系统会运行 `exec()` 来替换掉复制的进程。举个简单的例子，比如你在终端输入 `ls` 命令，终端会调用 `fork()` 创造一个 shell 的复制，然后执行 `exec(ls)` 来运行 `ls` 程序。过程如下图。

![start a new process](https://sherlockblaze.com/resources/img/linux/how-linux-works/starting-a-new-process.png)

内核还会向用户进程提供一些不同于传统系统调用的功能， 比较常见的，比如 ***伪设备***。伪设备对用户进程来说，就像是普通的设备，但是它是完全通过软件来实现的。从技术上来说，它们不必是内核的一部分，但是通常来说，它们的确是。比如说， `/dev/random` 需要通过内核来实现，因为通过用户进程来实现是非常困难的。

技术上来说，用户进程访问伪设备仍然需要通过系统调用的方式，所以用户进程无法避免使用系统调用。

### 用户空间

内核在主存中申请给用户进程的空间被称为 **用户空间**。因为一个进程只是主存里的一个状态，用户空间也可以说是一个所有运行进程的集合。

大多数实际的操作发生在用户空间。虽然从内核的角度来观察所有的进程都是一样的，但是它们为用户执行不同的任务。对于用户进程所代表的系统组件类型，存在基本的服务级别（或层）结构。下面的图片展示了一个关于组件集合相互写作以及和Linux系统进行交互的例子。最基本的服务在最底层（接近内核），公用服务在中间一层，用户接触的用户在最顶层。图片里仅仅展示了六个组件，但是很容易发现，用户能接触到的在顶层，在中层的组件，比如邮件服务是被浏览器使用的；然后底层有几个小的组件。

![Process types and interactions](https://sherlockblaze.com/resources/img/linux/how-linux-works/process-types-and-interactions.png)

最底下一层往往是由最简单的组件，执行单一、不算发杂的任务。中间的层则是一些比较大的组件，比如邮件、打印和数据库服务。最后，在最顶层的组件执行一些复杂的任务，一般来说，用户直接控制这些任务的完成。组件可以使用其他的组件，通常来说，如果一个组件需要使用另一个组件，那么被使用的组件需要在相同的等级或者比当前等级低。

但是，上面的图片仅仅是用户空间分布的一个大概。事实上，用户空间里是没有任何规则的。比如说，很多应用程序或者服务会用日志的形式来记录诊断信息。但部分程序用标准的syslog服务去写日志信息，但是也有一些会以自己的方式来完成日志的输出。

用户空间的组件是很难被归类的。服务类组件，比如网络服务、数据库服务，一般会被认为是高等级的应用，因为它们的任务通常比较复杂，从这个角度来考虑的话，在上面的图片中，你可以把它们放在最上面一层。但是，用户应用可能依赖这些服务去完成一些任务，而不是靠自己是做，所以你也可以把网络服务、数据库服务之类放到上图的中层。

### 用户

Linux内核支持一个传统的概念：Unix用户。一个**用户**通常是一个可以运行自己进程和查看自己文件的实体。用户会有一个相对应的用户名。

**内核不管理用户名，但是它会管理一个简单的数字序列，被称为 `userids`**。

**用户的存在主要是为了权限和操作边界的支持**。每个用户空间都有一个用户，作为**拥有者**存在，进程则被称为作为拥有者运行。一个用户可以选择终止或修改自己进程的行为（在某些限定条件下），但是不能和其他用户的进程进行交互。同时，用户可以选择是否和其他用户分享自己的文件。

最厉害的用户我们称之为 **root用户（管理员）**。root用户是上述所描述规则的一个例外，因为root用户可以终止或者修改其他用户的进程，可以读写本机任何其他用户的文件。因为这些骚操作，root用户也被称之为 **超级用户**。

 **用户组** 是一群用户的集合。用户组存在的主要目的就是为了让一个用户可以向组里其他用户分享自己的文件。
 
> 总是用超级用户的权限来访问是风骚而且极其危险的。因为系统允许超级用户做任何事情，包括对系统有害的事情。考虑到这一点，平时最好少用管理员权限。但是，有一点需要知道。哪怕超级用户这么吊，**它也是运行在用户模式的**，而不是内核模式。

### 结论

用户进程组成了你直接交互的环境，内核管理进程和硬件。内核以及所有的进程，都持久化在内存里运行。

### 推荐阅读

- 操作系统概念, 9th edition, by Abraham Silberschatz, Peter B. Galvin, and Greg Gagne (Wiley, 2012)
- 现代操作系统, 4th edition, by Andrew S. Tanenbaum and Herbert Bos (Prentice Hall, 2014).