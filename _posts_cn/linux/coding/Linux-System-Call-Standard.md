---
title: Linux 系统调用规范
tags: 
  - Linux
  - Linux 系统下编程
  - Linux 内核
  - Unix
date: 2019-02-26
---

# 系统调用规范

- [系统调用概述](#系统调用概述)
- [系统调用的两种方式](#系统调用的两种方式)
- [系统调用的两种执行过程](#系统调用的两种执行过程)
- [系统调用的标准使用方法](#系统调用的标准使用方法)

## 系统调用概述

定义：系统调用是操作系统内核提供给应用程序的**基础接口**，需要**运行在操作系统的核心模式下**。原因：确保有权限执行某些CPU特权指令。

通过以下命令可以查看系统中所有的系统调用名称。

```shell
man syscalls
```

## 系统调用的两种方式

1. `int syscall(int number, ...)`，这种方式是通过系统调用编号来进行调用的。`sys/syscall.h` 文件中保存着完整的系统调用编号。

2. 利用 glibc提供的包装函数将这些系统调用包装成名字自解释的函数。包装函数主要做了如下的工作：1. 检查参数 2. 拷贝到合适的寄存器中 3. 调用指定标号的系统调用 4. 根据结果设置errno 5. 其他

## 系统调用的两种执行过程

- [基于中断方式](#基于中断方式)
- [基于SYSENTER指令](#基于SYSENTER指令)

### 基于中断方式

执行系统调用代码，首先需要将系统从用户模式切换到核心模式。

早期系统调用**通过软中断实现模式的切换**，而中断号属于系统稀缺资源，在Linux实现中，所有的系统调用共用**128号中断**，(int 0x80)，对应的中断处理程序是 **system_call**，所有的系统调用都会转到这个中断处理程序中。system_call会根据EAX传入的系统调用标号跳转并执行相应的系统调用程序。函数执行完成后，将结果放到EAX中返回给应用程序。期间，如果需要更多参数，会依次用EBX、ECX、EDX、EDI进行传递。

**一次系统调用会触发一次完整的中断处理过程。**

在每次中断处理过程中，CPU会从系统启动时初始化好的中断描述表中，取出该中断对应的门描述符，并判断门描述符的种类。 

在确认门描述符的级别（DPL）不比中断指令调用者的级别（CPL）低之后，再根据描述符的内容，将中断处理程序中可能用到的寄存器进行压栈保存。最后执行权限提升，设置 CS 和 EIP 寄存器，让CPU跳转到指定的系统调用的代码地址，并执行目标系统调用。

### 基于SYSENTER指令

在中断方式的系统调用执行过程中，例如门描述符级别检查、查找中断处理程序入口，等等，其实是很没必要的。

Intel在 Pentium II CPU中加入了SYSENTER指令专门用来执行系统调用，该指令会跳过多余的检查，直接将CPU切换到特权模式，继而执行系统调用 ，同时增加了几个专用寄存器辅助完成参数传递和上下文保存工作。另外，相应增加了SYSEXIT指令，用于返回执行结果，并切回用户模式。因为省掉了级别检查类的操作，花费的时间大幅减少了45%左右；并且在核心模式下，因为少了一个寄存器压栈保存动作，所花费的时间也减少了2%左右。

Linux启动时会自动检测CPU是否支持SYSENTER指令，从而根据情况选择相应的系统调用方式。

## 系统调用的标准使用方法

glibc中的包装函数会在执行系统调用前设置寄存器状态，并仔细检查输入参数的有效性。系统调用执行完成后，会从EAX寄存器中获取内核代码执行的结果。

内核执行系统调用时，一旦发生错误，便将 EAX设置为一个负整数，包装函数随之将这个负数去掉符号后，放置到一个全局的errno中并返回-1.如果没有返回错误，EAX将被设置为0，包装函数获取该值后，并返回0，表示执行成功，此时无需在设置errno。

## 参考

[攻克Linux系统编程](https://gitbook.cn/gitchat/column/5bfbbe9b7d496f13396961de/topic/5c21aa444fcd483b0264eb19)

![](https://sherlockblaze.com/resources/img/linux/linux_programming_share.jpg)