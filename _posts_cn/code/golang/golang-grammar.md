---
title: Golang 语法
tags:
  - Golang
  - 编程语言
  - 编程
date: 2019-05-07
---

先讨论一些规范问题：

1. 如何将代码组织成包
2. 如何操作这些包

## 包

有这么一些目录，目录下存放一些列以 `.go` 为扩展名的相关文件，这个目录，称之为**包**。

同一个目录下的所有 `.go` 文件必须声明为同一个包名，比如包为 `beauty`，则需要在代码中标明 `package beauty`。

### main 包

所有用 Go 语言编译的可执行程序都必须有一个名叫 `main` 的包，当编译器找到 `main` 包，会去找寻 `main()` 函数，如果没有，则不会生成可运行二进制文件。

### 导入

导入一个包极其简单 ---- `import "beauty"`。注意，如果你导入了一个包，却不用，编译器会报错。

### init 函数

如你在[Golang 初探](https://sherlockblaze.com/2019/05/07/code/golang/golang-start/)所看到的，在 `matcher` 中，你会看到 `init` 函数，如果你以这种方式 `import _ "beauty"` 导入包，那么会在程序开始运行时，执行这个包下面的 `init` 函数。

## 数组

### 使用

```golang
// 声明一个长度为5的数组，其中的值初始化为0
var array1 [5]int
// 声明一个长度为5的数组，值为1、2、3、4、5
array2 := [5]int{1, 2, 3, 4, 5}
// 声明一个值为1、2、3、4、5，长度自动生成，为5
array3 := [...]int{1, 2, 3, 4, 5}
// 声明一个长度为5的数组，下标为1的值为1，下标为2的值为2，其他位置为0
array4 := [5]int{1: 1, 2: 2}
// 声明包含5个元素的指向整数的数组
array5 := [5]*int{0: new(int), 1: new(int)}
*array5[0] = 1
*array5[1] = 2
// 将数组array1赋值给array6，注意，是全盘复制，到时候你会有两个一样的数组
var array6 [5]int
array6 = array1
```

在函数间直接传递数组是直接**拷贝数组**，如果数组过大，直接传递指针即可。通过 `&` 符号，可以获取指定数组的地址，如：`&array1`。

## 切片

### 什么是切片

**切片**是一种数据结构，这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念来构建的，可以按需自动增长和缩小。切片的动态增长是通过函数 `append` 来实现的。同时，**切片的底层内存也是在连续块中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处。**

### 实现原理

![](https://sherlockblaze.com/resources/img/code/golang/slice.png)

### 使用

```golang
slice1 := make([]int, 5)
slice2 := make([]int, 3, 5)
slice3 := []int{1, 2, 3}
slice4 := []int{100: 100}
slice5 := []int
slice6 := make([]int, 0)
slice7 := []int{}
```