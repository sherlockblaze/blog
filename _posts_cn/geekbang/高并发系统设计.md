---
title: 高并发系统设计 40 问
tags:
  - 极客时间笔记
date: 2019-09-18
---

> 本文总结自极客时间专栏，[高并发系统设计40问](https://time.geekbang.org/column/intro/230)，持续更新

## 支持原版

![海报](https://sherlockblaze.com/resources/img/time-geekbang/高并发系统设计/海报.jpg)

## 为什么要学习高并发系统设计

**思考题**

- 微博中，明星动辄拥有几千万甚至上亿的粉丝，如何保证明星发布的内容让粉丝实时地看到
- 淘宝双十一，如何保证衣服不会超卖
- 12306 订购火车票，如何保证千万人访问的同时也能支持正常抢票

同样是缓存的使用，在低并发下你只需要了解基本的使用方式，但在高并发场景下需要关注**缓存命中率、如何应对缓存穿透、如何避免雪崩、如何解决缓存一致性等问题**，增加了设计方案的复杂度，对设计者能力的要求也会更高。

## 学习目标

- 掌握高并发系统设计的“套路”
- 理解基本的系统设计思想，对新的知识触类旁通，举一反三
- 突破技术的瓶颈，突破所处平台的限制，具备一个优秀架构师的资质

虽说每家公司所处的行业不同，业务场景不同，但是设计和优化的思想却是万变不离其宗。

本篇总结里的经验是一个个的“小套路”，它们相互联系，形成一套指引进行高并发系统设计的指示体系，其中包括了理论知识的讲解、问题场景的介绍、问题分析的过程，以及解决问题的思路。

当掌握这些“套路”后，就能明确地知道，系统处于某一阶段时，可能会面临的问题，然后及时找到架构设计优化的思路解决这些问题，提升系统性能。

## 系统的演进过程

- 最简单的系统设计满足业务需求和流量现状，选择最熟悉的技术体系
- 随着流量的增加和业务的变化，修正架构中存在问题的点，如单点问题，横向扩展问题，性能无法满足需求的组件。在这个过程中，选择社区成熟的、团队熟悉的组件来解决问题，社区没有合适解决方案的前提下才自己造轮子
- 对架构的小修小补无法满足需求时，考虑重构、重写等大的调整方式以解决现有问题

**高并发系统的演进应该是循序渐进，以解决系统中存在的问题为目的和驱动力的**

## 高并发系统的通用设计方法是什么

目标是抵抗巨大流量的冲击，让流量更加平稳地被系统中的服务和组件处理。

> 课程比喻： 从古至今，长江和黄河流域水患不断。
> **远古时期，大禹曾拓宽河道，清除淤沙让流水更加流畅**
> **都江堰作为史上最成功的治水案例之一，用引流将岷江之水分流到多个支流中，以分担水流压力**
> **三门峡和葛洲坝通过建造水库将水引入水库先存储起来，然后再想办法把水库中的水缓缓地排出去，以此提高下游的抗洪能力**

在应对高并发大流量时也会采用类似“抵御洪水”的方案：
- Scale-out（横向扩展）：分而治之是一种常见的高并发系统设计方法，采用分布式部署的方式把流量分开，让每个服务器都承担一部分并发和流量
- 缓存：使用缓存来提高系统的性能，就好比用“拓宽河道”的方式抵抗高并发大流量的冲击
- 异步：在某些场景下，未处理完成之前，可以先让请求返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求

### Scale-up 和 Scale-out

- Scale-up，通过购买性能更好的硬件来提升系统的并发处理能力，比如目前 4 核 4G 每秒可以处理 200 次请求，如果要处理 400 次请求呢？把机器的硬件提升到 8 核 8G（硬件资源的提升可能不是线性，仅供参考）
- Scale-out，通过将多个低性能的机器组成一个分布式集群来共同抵御高并发流量的冲击

**使用时机**

一般在系统设计初期会考虑使用 Scale-up 的方式，方案简单，但系统并发超过了单机极限时，就需要使用 Scale-out 的方式了。

Scale-out 虽可以突破单机限制，但也会引入一些复杂问题 —— 如何保证高可用？如何进行状态同步？如何无感知增加和删除节点？

### 缓存

使用缓存的主要作用是提升系统的访问性能。

可以将任何降低响应事件的中间存储都称为缓存，缓存的思想遍布很多设计领域，比如操作系统中 CPU 有多级缓存，文件有 Page Cache 缓存。

### 异步处理

同步调用代表调用方要阻塞等待被调用方法中的逻辑执行完成。这种方式下，当被调用方响应时间较长，会造成调用方长久的阻塞，在高并发系统下会造成整体系统性能下降甚至发生雪崩。

异步调用不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。

异步调用在大规模高并发系统中被大量使用，比如 12306。

订票时，页面会显示系统正在排队，代表着系统在异步处理订票请求。系统中查询余票、下单和更改余票状态都是比较耗时的操作，可能涉及多个内部系统的互相调用，如果是同步调用就会像 12306 刚刚上线时那样，高峰期永远不可能下单成功。

**处理逻辑后移到异步处理程序中，Web 服务的压力小了，资源占用的少了，自然就能接收更多的用户订票请求，系统承受高并发的能力也就提升了。**

![12306异步处理订票操作示意图](https://sherlockblaze.com/resources/img/time-geekbang/高并发系统设计/12306异步处理订票操作示意图.png)

## 架构分层

> 在系统从 0 到 1 的阶段，为了让系统快速上线，通常是不考虑分层的。但是随着业务越来越复杂，大量的代码纠缠在一起，会出现逻辑不清晰、各模块相互依赖、代码扩展性差、改动一处就牵一发而动全身等问题

### 什么是分层架构

它将整个系统拆分成 N 个层次，每个层次有独立的职责，多个层次协同提供完整的功能。

![mvc架构图](https://sherlockblaze.com/resources/img/time-geekbang/高并发系统设计/mvc架构图.png)

MVC 架构将整体的系统分成了 Model（模型）、View（视图）和 Controller（控制器）三个层次，也就是将用户视图和业务处理隔离开，并且通过控制器连接起来，很好的实现了表现和逻辑的解耦，是一种标准的软件分层结构。

**另外一种分层方式是将整体架构分为表现层、逻辑层和数据访问层：**

- 表现层，顾名思义，就是展示数据结果和接受用户指令的，最靠近用户的一层
- 逻辑层负责复杂业务的具体实现
- 数据访问层处理和存储之间的交互

### 例子

**OSI 网络模型**

![网络分层模型](https://sherlockblaze.com/resources/img/time-geekbang/高并发系统设计/网络分层模型.png)

它把整个网络分成了七层，自下而上分别是**物理层、数据链路层、网络层、传输层、会话层、表示层和应用层**

TCP/IP 协议把网络简化成了四层，即**链路层、网络层、传输层和应用层**。

**每一层各司其职又互相帮助**。

网络层负责端到端的寻址和建立连接，传输层负责端到端的数据传输等，相邻两层有数据交互。这样做**隔离了关注点，让不同的层专注做不同的事情。**

**Linux 文件系统**

![文件系统分层](https://sherlockblaze.com/resources/img/time-geekbang/高并发系统设计/文件系统分层.png)

文件系统最上层是虚拟文件系统(VFS)，用来屏蔽不同的文件系统之间的差异，提供统一的系统调用接口。虚拟文件系统的下层是 Ext3、Ext4 等各种文件系统，再向下是为了屏蔽不同硬件设备的实现细节，抽象出单独的一层 ———— 通用块设备层，再往下就是不同类型的磁盘了。

### 分层的好处

1. **简化系统设计，不同的层专注做事**
2. **高复用**
3. **更容易做横向扩展**

业务逻辑里面包含比较复杂的计算，导致 CPU 成为性能瓶颈，这样可以将逻辑层单独抽取出来独立部署，只对逻辑层做扩展，相对于针对整体系统扩展付出的代价小。

**架构分层和高并发设计的关系是怎样的？**横向扩展是高并发系统设计的常用方法之一，既然分层的架构可以为横向扩展提供便捷，那么支撑高并发的系统一定是分层的系统。

### 怎么分层

分层设计最主要的一点就是需要**理清每个层次的边界是什么**。

**例子**

任何一个系统中都有用户系统，最基本的接口是返回用户信息的接口，它调用逻辑层的 GetUser 方法，GetUser 方法又和 User DB 交互获取数据。

此时，产品提出一个需求，在 APP 中展示用户信息的时候，如果用户不存在，那么要自动给用户创建一个用户。同时，要做一个 HTML5 的页面，HTML5 页面要保留之前的逻辑，也就是不需要创建用户。这是逻辑层的边界就变得不清晰，表现层也承担了一部分的业务逻辑（将获取用户和创建用户接口编排起来）。

![获取用户信息接口的进化](https://sherlockblaze.com/resources/img/time-geekbang/高并发系统设计/获取用户信息接口的进化.png)

**进化！**

![阿里系统分层的规约](https://sherlockblaze.com/resources/img/time-geekbang/高并发系统设计/阿里系统分层的规约.png)

- 终端显示层：各端模板渲染并执行显示的层
- 开放接口层：将 Service 层方法封装成开放接口，同时进行网关安全控制和流量控制等
- Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等
- Service 层：业务逻辑层
- Manager 层：通用业务处理层。这一层主要有两个作用，其一，可以将原先 Service 层的一些通用能力下沉到这一层，比如与缓存和存储交互策略，中间件的介入；其二，可以在这一层封装对第三方接口的调用，比如调用支付系统，调用审核服务等
- DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互
- 外部接口或第三方平台：包括其他部门 RPC 开发接口，基础平台，其他公司的 HTTP 接口

Manager 层提供原子的服务接口，Service 层负责依据业务逻辑来编排原子接口。

Manager 层提供创建用户和获取用户信息的接口，而 Service 层负责将这两个接口组装起来。这样就把原先散步在表现层的业务逻辑都统一到了 Service 层，每一层的边界就非常清晰了。

除此之外，**分层架构需要考虑的另一个因素**是层次之间一定是相邻层互相依赖，**数据的流转也只能在相邻的两层之间流转**。

### 分层系统的不足

**分层架构最主要的一个缺陷就是增加了代码的复杂度。**

同时，因为每个层次独立部署，层次间通过网络来交互，那么多层的架构在性能上会有损耗。

> 这也是为什么服务化架构性能要比单体架构略差的原因，也就是所谓的“多级一跳”问题

### 总结

分层架构是软件设计思想的外在体现，是一种实现方式。一些熟知的软件设计原则都在分层架构中有所体现。

**单一职责原则**规定每个类只有单一的功能，在这里可以引申为每一层拥有单一职责，且层与层之间边界清晰；

**迪米特法则**原意是一个对象应当对其他对象有尽可能少的了解，在分层架构的体现是数据的交互不能跨层，只能在相邻层之间进行；

**开闭原则**要求软件对扩展开放，对修改关闭。它的含义其实就是将抽象层和实现层分离，抽象层是对实现层共有特征的归纳总结，不可以修改，但是具体的实现可以是无限扩展，随意替换的。